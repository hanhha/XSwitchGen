// HMTH (c)

module <%=cmm_prefix%>XAFifo #(parameter DEPTH = 4, DW = 8, W_SYNC_N = 2, R_SYNC_N = 2) (
    input  logic rclk
  , input  logic rrstn

  , input  logic re
  , output logic empty_n

  , input  logic wclk
  , input  logic wrstn

  , input  logic we
  , output logic full_n

	, input  logic [DW-1:0] din
	, output logic [DW-1:0] dout
);

logic                       we_ok;
logic [$clog2(DEPTH) : 0]   a_g_wptr;
logic [$clog2(DEPTH) : 0]   a_g_rptr;

logic [$clog2(DEPTH)-1 : 0] rptr;
logic [$clog2(DEPTH)-1 : 0] wptr;

<%=cmm_prefix%>XAFifoWCtrl #(.DEPTH(DEPTH), .SYNC_N(W_SYNC_N))
	WCtrl (.clk(wclk), .rstn(wrstn), .we(we), .full_n(full_n), .a_g_rptr(a_g_rptr), .a_g_wptr(a_g_wptr), .we_ok(we_ok), .wptr(wptr));

<%=cmm_prefix%>XAFifoRCtrl #(.DEPTH(DEPTH), .SYNC_N(R_SYNC_N))
	RCtrl (.clk(rclk), .rstn(rrstn), .re(re), .empty_n(empty_n), .a_g_rptr(a_g_rptr), .a_g_wptr(a_g_wptr), .rptr(rptr));

<%=cmm_prefix%>XMem #(.DW(DW), .DEPTH(DEPTH))
	Mem (.clk(wclk), .we(we_ok), .waddr(wptr), .raddr(rptr), .d(din), .q(dout));

endmodule

module <%=cmm_prefix%>XAFifoWCtrl #(parameter DEPTH = 4, SYNC_N = 2) (
    input  logic clk
  , input  logic rstn

  , input  logic we
  , output logic full_n

  , input  logic [$clog2(DEPTH) : 0]   a_g_rptr
  , output logic                       we_ok
  , output logic [$clog2(DEPTH)-1 : 0] wptr
  , output logic [$clog2(DEPTH) : 0]   a_g_wptr
);

localparam AW = $clog2(DEPTH);

logic [AW:0] synced_g_rptr;
logic [AW:0] nxt_bin_cnt, bin_cnt, nxt_g_wptr;

<%=cmm_prefix%>MultiBitSyncer #(.DW(AW+1), .N(SYNC_N)) rptr_syncer (.clk(clk), .rstn(rstn), .d(a_g_rptr), .q(synced_g_rptr));

`ifndef SELECT_SRSTn 
always @(posedge clk, negedge rstn) begin
`else
always @(posedge clk) begin
`endif
  if (~rstn) begin
    bin_cnt                        <= {(AW+1){1'b0}};
    a_g_wptr                       <= {(AW+1){1'b0}};
    full_n                         <= 1'b1;
  end else begin
    bin_cnt                        <= nxt_bin_cnt;
    a_g_wptr                       <= nxt_g_wptr;
    full_n                         <= (nxt_g_wptr [AW] != synced_g_rptr [AW]) && (nxt_g_wptr [AW-1] == ~synced_g_rptr [AW-1]) && (nxt_g_wptr [AW-2:0] == synced_g_rptr [AW-2:0]) ? 1'b0 : 1'b1;
  end
end

assign wptr  = bin_cnt [AW-1:0];
assign we_ok = we & full_n;

assign nxt_bin_cnt = we_ok ? bin_cnt + 1'b1 : bin_cnt;
assign nxt_g_wptr  = (nxt_bin_cnt >> 1) ^ nxt_bin_cnt;

endmodule

module <%=cmm_prefix%>XAFifoRCtrl #(parameter DEPTH = 4, SYNC_N = 2) (
    input  logic clk
  , input  logic rstn

  , input  logic re
  , output logic empty_n

  , input  logic [$clog2(DEPTH) : 0]   a_g_wptr
  , output logic [$clog2(DEPTH)-1 : 0] rptr
  , output logic [$clog2(DEPTH) : 0]   a_g_rptr
);

localparam AW = $clog2(DEPTH);

logic        re_ok;
logic [AW:0] synced_g_wptr;
logic [AW:0] nxt_bin_cnt, bin_cnt, nxt_g_rptr;

<%=cmm_prefix%>MultiBitSyncer #(.DW(AW+1), .N(SYNC_N)) wptr_syncer (.clk(clk), .rstn(rstn), .d(a_g_wptr), .q(synced_g_wptr));

`ifndef SELECT_SRSTn 
always @(posedge clk, negedge rstn) begin
`else
always @(posedge clk) begin
`endif
  if (~rstn) begin
    bin_cnt                        <= {(AW+1){1'b0}};
    a_g_rptr                       <= {(AW+1){1'b0}};
    empty_n                        <= 1'b0;
  end else begin
    bin_cnt                        <= nxt_bin_cnt;
    a_g_rptr                       <= nxt_g_rptr;
    empty_n                        <= synced_g_wptr == nxt_g_rptr ? 1'b0 : 1'b1;
  end
end

assign rptr  = bin_cnt [AW-1:0];
assign re_ok = re & empty_n;

assign nxt_bin_cnt = re_ok ? bin_cnt + 1'b1 : bin_cnt;
assign nxt_g_rptr  = (nxt_bin_cnt >> 1) ^ nxt_bin_cnt;

endmodule

// Below FIFO must have DEPTH that is power of 2
module <%=cmm_prefix%>XFifo #(parameter DW = 8, DEPTH = 4) (
    input  logic clk
  , input  logic rstn

  , input  logic we
  , input  logic re

	, input  [DW-1:0] din
	, output [DW-1:0] dout

  , output logic full_n
  , output logic empty_n
);

localparam AW = DEPTH > 1 ? $clog2(DEPTH) : 1;

logic [AW-1:0] rptr, wptr;
logic          we_ok;

<%=cmm_prefix%>XFifoCtrl #(DEPTH)
	Ctrl (.clk(clk), .rstn(rstn), .we(we), .re(re), .full_n(full_n), .empty_n(empty_n),
				.we_ok(we_ok), .wptr(wptr), .rptr(rptr));

<%=cmm_prefix%>XMem #(.DW(DW), .DEPTH(DEPTH))
	Mem (.clk(clk), .we(we_ok), .waddr(wptr), .raddr(rptr), .d(din), .q(dout));

endmodule

// Below FIFO must have DEPTH that is power of 2 and > 1
module <%=cmm_prefix%>XFifoCtrl #(parameter DEPTH = 4) (
    input  logic clk
  , input  logic rstn

  , input  logic we
  , input  logic re

	, output logic we_ok
	, output logic [$clog2(DEPTH)-1:0] wptr
	, output logic [$clog2(DEPTH)-1:0] rptr

  , output logic full_n
  , output logic empty_n
);

localparam AW = DEPTH > 1 ? $clog2(DEPTH) : 1;

`ifndef SYNTHESIS
	initial begin
		assert (DEPTH[0] == 1'b0);
	end
`endif

logic re_ok;
logic [AW-1:0] nxt_rptr;
logic r_ovf, nxt_r_ovf, tmp_nxt_r_ovf;

logic [AW-1:0] nxt_wptr;
logic w_ovf, nxt_w_ovf, tmp_nxt_w_ovf;

assign re_ok                     = re & empty_n;
assign {tmp_nxt_r_ovf, nxt_rptr} = re_ok ? rptr + 1'b1 : {1'b0, rptr}; 
assign nxt_r_ovf                 = r_ovf ^ tmp_nxt_r_ovf;

`ifndef SELECT_SRSTn
always @(posedge clk or negedge rstn) begin
`else
always @(posedge clk) begin
`endif
  if (rstn == 1'b0) begin
    {r_ovf, rptr} <= {1'b0, {AW{1'b0}}};
    empty_n       <= 1'b0;
  end else begin
    {r_ovf, rptr} <= {nxt_r_ovf, nxt_rptr};
		empty_n       <= {nxt_w_ovf, nxt_wptr} == {nxt_r_ovf, nxt_rptr} ? 1'b0 : 1'b1;
  end
end

assign we_ok                     = we & full_n;
assign {tmp_nxt_w_ovf, nxt_wptr} = we_ok ? wptr + 1'b1 : {1'b0, wptr}; 
assign nxt_w_ovf                 = w_ovf ^ tmp_nxt_w_ovf;

`ifndef SELECT_SRSTn
always @(posedge clk or negedge rstn) begin
`else
always @(posedge clk) begin
`endif
  if (rstn == 1'b0) begin
    {w_ovf, wptr} <= {1'b0, {AW{1'b0}}};
    full_n        <= 1'b1;
  end else begin
    {w_ovf, wptr} <= {nxt_w_ovf, nxt_wptr};
		full_n        <= {nxt_w_ovf, nxt_wptr} == {~nxt_r_ovf, nxt_rptr} ? 1'b0 : 1'b1;
  end
end

`ifndef SYNTHESIS
`ifdef FORMAL
logic init = 1'b1;
always @(posedge clk) begin
  if (init) assume (~rstn);
  init <= 1'b0;
end

// Validating FIFO's behaviors
logic [AW:0] entry_cnt;

always @(posedge clk or negedge rstn) begin
  if (~rstn) entry_cnt <= {(AW+1){1'b0}};
  else begin
    case ({we & full_n, re & empty_n})
      2'b00, 2'b11: entry_cnt <= entry_cnt;
      2'b01: entry_cnt <= entry_cnt - 1'b1;
      2'b10: entry_cnt <= entry_cnt + 1'b1;
      default: entry_cnt <= entry_cnt;
    endcase
  end
end

always @(posedge clk) begin
  if (rstn) begin
    assert (entry_cnt >= 0 && entry_cnt <= DEPTH); // Entry counter must not overflow/underflow
    if (empty_n == 1'b0) assert (entry_cnt == 0);
    if (full_n  == 1'b0) assert (entry_cnt == DEPTH);
  end
end
`endif
`endif
endmodule
// Round-robin arbiter

module <%=cmm_prefix%>XArbiter_RR #(parameter REQ_N = <%=n_initiators%>) (
    input logic clk
  , input logic rstn

  , input  logic [REQ_N-1:0] req
  , output logic [REQ_N-1:0] gnt
);

logic [REQ_N-1:0] mask, nxt_mask;
logic [REQ_N-1:0] masked_req;

<%=cmm_prefix%>XArbFirstOneBit #(.DW(REQ_N), .MASK_OUT(1)) mask_gen (.i(gnt), .o(nxt_mask));

`ifndef SELECT_SRSTn
always @(posedge clk or negedge rstn) begin
`else
always @(posedge clk) begin
`endif
  if (~rstn) mask <= {REQ_N{1'b1}};
  else       mask <= |gnt ? nxt_mask : mask;
end

assign masked_req = req & mask;

logic [REQ_N-1:0] pre_gnt, pos_gnt;

// Before pivot
<%=cmm_prefix%>XArbFirstOneBit #(.DW(REQ_N), .MASK_OUT(0)) pre_gnt_gen (.i(req), .o(pre_gnt));

// After pivot
<%=cmm_prefix%>XArbFirstOneBit #(.DW(REQ_N), .MASK_OUT(0)) pos_gnt_gen (.i(masked_req), .o(pos_gnt));

assign gnt = |masked_req ? pos_gnt : pre_gnt;

`ifndef SYNTHESIS
  `ifndef RICHMAN
    integer ones;
    integer i;

		/* verilator lint_off WIDTH */
    always @(*) begin
      ones = 0;
      for (i = 0; i < REQ_N; i++) begin 
        ones = ones + gnt [i];
      end
      if (|req) assert (ones == 1);
    end
		/* verilator lint_on WIDTH */
  `else
    always @(*) begin
      assert (req |-> $onehot0 (gnt));
    end
  `endif
`endif

endmodule

module <%=cmm_prefix%>XHndSk #(parameter D_WIDTH = 16)
(
  input  logic clk,
  input  logic rstn,

  input  logic vldi,
  input  logic rdyo,
  input  logic [D_WIDTH-1:0] datai,

  output logic vldo,
  output logic rdyi,
  output logic [D_WIDTH-1:0] datao
);

  localparam IDLE = 1'b1;
  localparam BUSY = 1'b0;

  logic state, nxt_state;
  logic nxt_vldo;
  logic [D_WIDTH-1:0] nxt_datao;

  assign nxt_state = rdyo ? IDLE : 
                            vldi ? BUSY : state;
  assign nxt_vldo  = state == IDLE ? vldi :
                                     rdyo ? vldi : vldo;
  assign nxt_datao = state == IDLE ? datai :
                                     rdyo ? datai : datao;

`ifndef SELECT_SRSTn
always @(posedge clk or negedge rstn) begin
`else
always @(posedge clk) begin
`endif
  if (rstn == 1'b0) begin
    state <= IDLE;
    vldo  <= 1'b0;
    datao <= {(D_WIDTH){1'b0}};
  end else begin
    state <= nxt_state;
    vldo  <= nxt_vldo;
    datao <= nxt_datao;
  end
end

assign rdyi = rdyo;

endmodule

module <%=cmm_prefix%>XRegSlice #(parameter D_WIDTH = 16)
(
  input  logic clk,
  input  logic rstn,

  input  logic vldi,
  input  logic rdyo,
  input  logic [D_WIDTH-1:0] datai,

  output logic vldo,
  output logic rdyi,
  output logic [D_WIDTH-1:0] datao
);

  localparam IDLE  = 2'b01;
  localparam BUSY0 = 2'b00;
  localparam BUSY1 = 2'b10;

  logic [1:0] state, nxt_state;
  logic nxt_vldo;
  logic [D_WIDTH-1:0] nxt_datao, saved_data;

`ifndef SELECT_SRSTn
always @(posedge clk or negedge rstn) begin
`else
always @(posedge clk) begin
`endif
  if (rstn == 1'b0) begin
    state <= BUSY0;
    vldo  <= 1'b0;
  end else begin
    case (state):
      IDLE:  begin
               state <= rdyo ? IDLE
                             : vldi & vldo ? BUSY1
                                           : vldi ? BUSY0 : state;
               vldo  <= vldi;
               datao <= rdyo ? datai
                             : ~vldi & vldo ? datai : datao;
               saved_data <= ~rdyo & vldo ? datai : saved_data;
             end
      BUSY0: begin
               state <= rdyo ? IDLE : state;
               vldo  <= rdyo ? 1'b0 : vldo;
             end
      BUSY1: begin
							 state <= rdyo ? BUSY0 : state;
							 datao <= rdyo ? saved_data : datao;
             end
      default: begin
                 state      <= 2'bX;
                 vldo       <= 1'bX;
                 datao      <= {(D_WIDTH){1'bx}};
                 saved_data <= {(D_WIDTH){1'bx}};
               end
    endcase
  end
end

assign rdyi = state [0];

`ifndef SYNTHESIS
  `ifndef RICHMAN
logic init = 1'b1;
always @(posedge clk) begin
  if (init) assume (~rstn);
  init <= 1'b0;
end

// Validating register slice behavior 
always @(posedge clk) begin
  if (rstn) begin
    if ($past(vldi) & $past(rdyo)) assert (vldo & (datao == $past(datai))); // After 1 cycle, data must arrive output port
  end
end
  `else
		ast_delay_1cyc: assert property (@(posedge clk) disable iff (!rstn) vldi & rdyo |=> vldo & (datao = $past(datai)));
	`endif
`endif
endmodule

// ============================================================================
// Quick explanation: 4'b0110 => 4'b0010 (MASK_OUT == 0)
//                    4'b0110 => 4'b1100 (MASK_OUT == 1 - output mask instead)
// ============================================================================
module <%=cmm_prefix%>XArbFirstOneBit #(parameter DW = 8, MASK_OUT = 0) (
  input  logic [DW-1:0] i,
  output logic [DW-1:0] o
);

logic [DW-1:0] mask;

localparam N = $clog2(DW);

logic [DW*(N+1)-1:0] comp_grid;

integer k, l;
always @(*) begin
  comp_grid [DW-1:0] = i;
  for (l = 1; l <=N; l++) begin
    for (k = 0; k < DW; k=k+2)
      if (k < (l == 1 ? 0 : 1 << (l-1))) begin
        comp_grid[DW*l + k]   = comp_grid[(l-1)*DW + k];
        if (k < DW-1)
          comp_grid[DW*l + k+1] = comp_grid[(l-1)*DW + k+1];
      end else begin
        comp_grid[l*DW + k]   = comp_grid[(l-1)*DW + k]   | comp_grid[(l-1)*DW + k -( (1 << (l-1))-1 )];
        if (k < DW-1)
          comp_grid[l*DW + k+1] = comp_grid[(l-1)*DW + k+1] | comp_grid[(l-1)*DW + k -( (1 << (l-1))-1 )];
      end
  end
end

assign mask = comp_grid [(N*DW) +: DW];

assign o = MASK_OUT == 0 ? i & ~(mask << 1) : mask << 1;

endmodule

module <%=cmm_prefix%>MultiBitSyncer #(parameter DW = 2, N = 2) (
  input logic clk,
  input logic rstn,

  input  logic [DW-1:0] d,
  output logic [DW-1:0] q
);

genvar i;
for (i = 0; i < DW; i = i + 1) begin: sync_all_bit
  <%=cmm_prefix%>Syncer #(.N(N)) bit_sync (.clk(clk), .rstn(rstn), .d(d[i]), .q(q[i]));
end

endmodule

// Read-Writable Master with different bus width than system data bus
module <%=cmm_prefix%>XMstRWSTrans #(parameter AW = 19, DW = 8, VDW = 74, OUTSTANDING_NUM = 2, ID = 0, SYS_AW = 32, SYS_DW = 32) (
    input logic clk
  , input logic rstn

  , input  logic              req_vld
  , output logic              req_gnt
  , input  logic [AW-1:0]     req_adr
  , input  logic [DW-1:0]     req_dat
	, input  logic              req_wr
	, input  logic [(DW/8)-1:0] req_strb

  , output logic           tpkt_vld
  , output logic [VDW-1:0] tpkt_dat // {INITID, TGTID, LOAD = (S_ADR, WE, S_STRB, S_DATA) }
  , input  logic           tpkt_gnt

  , input  logic                               rpkt_vld
  , output logic                               rpkt_gnt
  , input  logic [VDW-SYS_AW-(SYS_DW/8)-1-1:0] rpkt_dat // {TGTID, INITID, LOAD = (S_DATA) }

  , output logic           rsp_vld
  , input  logic           rsp_gnt
  , output logic [DW-1:0]  rsp_dat
);

logic [<%=targetid_width-1%>:0] tgtid;

logic <%=", ".join(["T" + str(i) + "_hit" for i in range(n_targets)])%>;

/* verilator lint_off WIDTH */
<%for i in range(n_targets):%>
assign T<%=i%>_hit = (req_adr & <%=address_map["T"+str(i)][0]%>) == <%=address_map["T"+str(i)][1]%> ? 1'b1 : 1'b0;
<%%>
/* verilator lint_on WIDTH */

assign tgtid = <%=" | ".join(["{" + str(targetid_width) + "{T" + str(i) + "_hit}} & " + str(targetid_width) + "'d" + str(i) for i in range(n_targets)])%>;

localparam HIDX = $clog2 (SYS_DW / 8) - 1;
localparam LIDX = $clog2 (DW / 8);

localparam SYS_STRB  = SYS_DW / 8;
localparam LOC_VDW   = AW + SYS_DW + SYS_STRB + 1 + <%=targetid_width%>;

localparam FB_VDW = VDW - SYS_AW - SYS_STRB - 1;

localparam MUL_DW       = $clog2(DW);
localparam MUL_DW_1_8th = $clog2(DW/8);

logic [LOC_VDW-1:0]  req_pkt, tmp_tpkt_dat;
logic [SYS_DW-1:0]   aligned_req_dat;
logic [SYS_STRB-1:0] aligned_req_strb;

/* verilator lint_off WIDTH */
always @(*) begin
	aligned_req_strb = {(SYS_STRB){1'b0}};
	aligned_req_dat  = {(SYS_DW){1'b0}};
	aligned_req_strb [(req_adr [HIDX:LIDX] << MUL_DW_1_8th) +: (DW/8)] = req_strb; 
	aligned_req_dat  [(req_adr [HIDX:LIDX] << MUL_DW) +: DW] = req_dat; 
end
/* verilator lint_on WIDTH */

assign req_pkt = {tgtid, req_adr, req_wr, aligned_req_strb, aligned_req_dat};

logic [HIDX - LIDX : 0] rpkt_dat_idx;
logic wait_rsp;

`ifndef SELECT_SRSTn
always @(posedge clk or negedge rstn) begin
`else
always @(posedge clk) begin
`endif
	if (rstn == 1'b0) begin
		wait_rsp <= 1'b0;
	end else begin
		if (tpkt_vld & tpkt_gnt) begin
			wait_rsp <= 1'b1;
			rpkt_dat_idx <= tpkt_dat [(SYS_DW + SYS_STRB + 1 + LIDX) +: (HIDX - LIDX + 1)];
		end else if (rsp_vld & rsp_gnt)
			wait_rsp <= 1'b0;
		else
			wait_rsp <= wait_rsp;
	end
end

logic tmp_tpkt_vld, tmp_tpkt_gnt;

assign tmp_tpkt_gnt = tpkt_gnt & ~wait_rsp;
assign tpkt_vld     = tmp_tpkt_vld & ~wait_rsp;

<%=cmm_prefix%>XFifo #(.DW(LOC_VDW), .DEPTH(OUTSTANDING_NUM))
  ReqBuff (.clk (clk), .rstn (rstn),
        .din    (req_pkt),      .we      (req_vld),
        .dout   (tmp_tpkt_dat), .re      (tmp_tpkt_gnt),
        .full_n (req_gnt),      .empty_n (tmp_tpkt_vld)
);

assign tpkt_dat = {ID[<%=initid_width-1%>:0], tmp_tpkt_dat [(LOC_VDW-1) -: <%=targetid_width%>], {(SYS_AW-AW){1'b0}}, tmp_tpkt_dat [SYS_DW + SYS_STRB + 1 + AW - 1 : 0]};

<%=cmm_prefix%>XHndSk #(.D_WIDTH (DW))
	RspHndSk (.clk (clk), .rstn (rstn),
					  .vldi  (rpkt_vld), .rdyi (rpkt_gnt),
						.vldo  (rsp_vld),  .rdyo (rsp_gnt),
						/* verilator lint_off WIDTH */
						.datai (rpkt_dat [(rpkt_dat_idx << MUL_DW) +: DW]),
						/* verilator lint_on WIDTH */
						.datao (rsp_dat)
);

`ifndef SYNTHESIS
// Validating address 
  `ifndef RICHMAN
		always @(posedge clk) begin
			if (rstn)
				if (req_vld) assume (<%=" + ".join(["T" + str(i) + "_hit" for i in range(n_targets)])%> == 1);
		end
  `else
    asm_ADR_VLD: assume property (@(posedge clk) disable iff (~rstn) (req_vld |-> $onehot({<%=", ".join(["T" + str(i) + "_hit" for i in range(n_targets)])%>})));
  `endif
`endif

endmodule

// Read-Writable Slave with different bus width than system data bus
module <%=cmm_prefix%>XSlvRWSTrans #(parameter AW = 19, DW = 8, VDW = 74, SYS_AW = 32, SYS_DW = 32, OUTSTANDING_NUM = 2, ID = 0) (
    input logic clk
  , input logic rstn

  , input  logic           tpkt_vld
  , input  logic [VDW-1:0] tpkt_dat // {INITID, TGTID, LOAD = (S_ADR, WE, S_STRB, S_DATA) }
  , output logic           tpkt_gnt

  , output logic              req_vld
  , input  logic              req_gnt
	, output logic              req_wr
  , output logic [AW-1:0]     req_adr
	, output logic [(DW/8)-1:0] req_strb
  , output logic [DW-1:0]     req_dat

  , input  logic           rsp_vld
  , output logic           rsp_gnt
  , input  logic [DW-1:0]  rsp_dat

  , output logic                               rpkt_vld
  , input  logic                               rpkt_gnt
  , output logic [VDW-SYS_AW-(SYS_DW/8)-1-1:0] rpkt_dat // {TGTID, INITID, LOAD = (S_DATA) }
);

localparam SYS_STRB  = SYS_DW / 8;

`ifndef SYNTHESIS
// Validating input
	`ifndef RICHMAN
		logic [SYS_STRB-1:0] s_strb;
		/* verilator lint_off WIDTH */
		always @(posedge clk) begin
			if (rstn)
				if (tpkt_vld) begin
					s_strb = tpkt_dat [SYS_DW +: SYS_STRB];
					assume (<%=" + ".join(["s_strb [" + str(i) + "]" for i in range(datawidth//8)])%> <= (DW / 8));
				end
		end
		/* verilator lint_on WIDTH */
	`else
		ast_TGT_ENOUGH: assert property (@(posedge clk) disable iff (~rstn) (tpkt_vld |-> $countones(tpkt_dat [SYS_DW +: SYS_STRB]) <= (DW / 8))); 
	`endif
`endif

localparam LOC_VDW = AW + DW + <%=initid_width%> + 1 + DW/8;
localparam FB_VDW = VDW - SYS_AW - SYS_STRB - 1;

localparam HIDX = $clog2 (SYS_DW / 8) - 1;
localparam LIDX = $clog2 (DW / 8);

localparam MUL_DW       = $clog2(DW);
localparam MUL_DW_1_8th = $clog2(DW/8);

logic [LOC_VDW-1:0] req_pkt, tmp_req_attr;
logic [DW-1:0]     tmp_req_dat;
logic [(DW/8)-1:0] tmp_req_strb;
logic [AW-1:0]     tmp_req_adr;
logic              tmp_req_wr;

assign tmp_req_adr  = tpkt_dat [(SYS_DW + SYS_STRB + 1) +: AW];
/* verilator lint_off WIDTH */
assign tmp_req_dat  = tpkt_dat [(tmp_req_adr [HIDX:LIDX] << MUL_DW) +: DW];
assign tmp_req_strb = tpkt_dat [(SYS_DW + (tmp_req_adr [HIDX:LIDX] << MUL_DW_1_8th)) +: (DW/8)];
/* verilator lint_on WIDTH */
assign tmp_req_wr   = tpkt_dat [SYS_DW + SYS_STRB];
assign req_pkt = {tpkt_dat[(VDW-1) -: <%=initid_width%>], tmp_req_adr, tmp_req_wr, tmp_req_strb, tmp_req_dat};

<%=cmm_prefix%>XFifo #(.DW(LOC_VDW), .DEPTH(OUTSTANDING_NUM))
  ReqBuff (.clk (clk), .rstn (rstn),
        .din    (req_pkt),     .we      (tpkt_vld),
        .dout   (tmp_req_attr), .re      (req_gnt),
        .full_n (tpkt_gnt),    .empty_n (req_vld)
);

assign {req_adr, req_wr, req_strb, req_dat} = tmp_req_attr [DW + DW/8 + 1 + AW - 1 : 0];

logic [<%=initid_width-1%>:0] init_id;

<%=cmm_prefix%>XFifo #(.DW(<%=initid_width%>), .DEPTH(OUTSTANDING_NUM))
  IdBuff (.clk (clk), .rstn (rstn),
        .din    (tmp_req_attr [(LOC_VDW-1) -: <%=initid_width%>]), .we (req_vld & req_gnt),
        .dout   (init_id),                       .re (rsp_vld & rpkt_gnt),
        .full_n (), .empty_n ()
);

logic [HIDX - LIDX : 0] rsp_dat_idx;

<%=cmm_prefix%>XFifo #(.DW(HIDX - LIDX + 1), .DEPTH(OUTSTANDING_NUM))
  AdrBuff (.clk (clk), .rstn (rstn),
        .din    (tmp_req_attr [(DW + DW/8 + 1 + LIDX) +: (HIDX - LIDX + 1)]), .we (req_vld & req_gnt),
        .dout   (rsp_dat_idx),                       .re (rsp_vld & rpkt_gnt),
        .full_n (), .empty_n ()
);

logic [FB_VDW-1:0] tmp_rpkt_dat;
logic [SYS_DW-1:0] rsp_sys_dat;

always @(*) begin
	rsp_sys_dat = {(SYS_DW){1'b0}};
/* verilator lint_off WIDTH */
	rsp_sys_dat [(rsp_dat_idx << MUL_DW) +: DW] = rsp_dat;
/* verilator lint_on WIDTH */
end

assign tmp_rpkt_dat = {ID [<%=targetid_width-1%>:0], init_id, rsp_sys_dat};

<%=cmm_prefix%>XHndSk #(.D_WIDTH (FB_VDW))
	RspHndSk (.clk (clk), .rstn (rstn),
					  .vldi (rsp_vld),  .rdyi (rsp_gnt),
						.vldo (rpkt_vld), .rdyo (rpkt_gnt),
						.datai (tmp_rpkt_dat),
						.datao (rpkt_dat)
);

endmodule

// Read-Writable Master with bus width as same as system data bus
module <%=cmm_prefix%>XMstRWTrans #(parameter AW = 19, VDW = 74, OUTSTANDING_NUM = 2, ID = 0, SYS_AW = 32, SYS_DW = 32) (
    input logic clk
  , input logic rstn

  , input  logic                  req_vld
  , output logic                  req_gnt
  , input  logic [AW-1:0]         req_adr
  , input  logic [SYS_DW-1:0]     req_dat
	, input  logic                  req_wr
	, input  logic [(SYS_DW/8)-1:0] req_strb

  , output logic           tpkt_vld
  , output logic [VDW-1:0] tpkt_dat // {INITID, TGTID, LOAD = (S_ADR, WE, S_STRB, S_DATA) }
  , input  logic           tpkt_gnt

  , input  logic                               rpkt_vld
  , output logic                               rpkt_gnt
  , input  logic [VDW-SYS_AW-(SYS_DW/8)-1-1:0] rpkt_dat // {TGTID, INITID, LOAD = (S_DATA) }

  , output logic               rsp_vld
  , input  logic               rsp_gnt
  , output logic [SYS_DW-1:0]  rsp_dat
);

logic [<%=targetid_width-1%>:0] tgtid;

logic <%=", ".join(["T" + str(i) + "_hit" for i in range(n_targets)])%>;

/* verilator lint_off WIDTH */
<%for i in range(n_targets):%>
assign T<%=i%>_hit = (req_adr & <%=address_map["T"+str(i)][0]%>) == <%=address_map["T"+str(i)][1]%> ? 1'b1 : 1'b0;
<%%>
/* verilator lint_on WIDTH */

assign tgtid = <%=" | ".join(["{" + str(targetid_width) + "{T" + str(i) + "_hit}} & " + str(targetid_width) + "'d" + str(i) for i in range(n_targets)])%>;

localparam SYS_STRB  = SYS_DW / 8;
localparam LOC_VDW   = AW + SYS_DW + SYS_STRB + 1 + <%=targetid_width%>;
localparam FB_VDW = VDW - SYS_AW - SYS_STRB - 1;

logic [LOC_VDW-1:0]  req_pkt, tmp_tpkt_dat;
logic [SYS_DW-1:0]   aligned_req_dat;
logic [SYS_STRB-1:0] aligned_req_strb;

assign aligned_req_strb = req_strb; 
assign aligned_req_dat  = req_dat; 

assign req_pkt = {tgtid, req_adr, req_wr, aligned_req_strb, aligned_req_dat};

logic wait_rsp;

`ifndef SELECT_SRSTn
always @(posedge clk or negedge rstn) begin
`else
always @(posedge clk) begin
`endif
	if (rstn == 1'b0) begin
		wait_rsp <= 1'b0;
	end else begin
		if (tpkt_vld & tpkt_gnt)
			wait_rsp <= 1'b1;
		else if (rsp_vld & rsp_gnt)
			wait_rsp <= 1'b0;
		else
			wait_rsp <= wait_rsp;
	end
end

logic tmp_tpkt_vld, tmp_tpkt_gnt;

assign tmp_tpkt_gnt = tpkt_gnt & ~wait_rsp;
assign tpkt_vld     = tmp_tpkt_vld & ~wait_rsp;

<%=cmm_prefix%>XFifo #(.DW(LOC_VDW), .DEPTH(OUTSTANDING_NUM))
  ReqBuff (.clk (clk), .rstn (rstn),
        .din    (req_pkt),      .we      (req_vld),
        .dout   (tmp_tpkt_dat), .re      (tmp_tpkt_gnt),
        .full_n (req_gnt),      .empty_n (tmp_tpkt_vld)
);

assign tpkt_dat = {ID[<%=initid_width-1%>:0], tmp_tpkt_dat [(LOC_VDW-1) -: <%=targetid_width%>], {(SYS_AW-AW){1'b0}}, tmp_tpkt_dat [SYS_DW + SYS_STRB + 1 + AW - 1 : 0]};

<%=cmm_prefix%>XHndSk #(.D_WIDTH (SYS_DW))
	RspHndSk (.clk (clk), .rstn (rstn),
					  .vldi  (rpkt_vld), .rdyi (rpkt_gnt),
						.vldo  (rsp_vld),  .rdyo (rsp_gnt),
						.datai (rpkt_dat [SYS_DW-1:0]),
						.datao (rsp_dat)
);

endmodule

// Read-Writable Slave with bus width as same as system data bus
module <%=cmm_prefix%>XSlvRWTrans #(parameter AW = 19, VDW = 74, SYS_AW = 32, SYS_DW = 32, OUTSTANDING_NUM = 2, ID = 0) (
    input logic clk
  , input logic rstn

  , input  logic           tpkt_vld
  , input  logic [VDW-1:0] tpkt_dat // {INITID, TGTID, LOAD = (S_ADR, WE, S_STRB, S_DATA) }
  , output logic           tpkt_gnt

  , output logic                  req_vld
  , input  logic                  req_gnt
	, output logic                  req_wr
  , output logic [AW-1:0]         req_adr
	, output logic [(SYS_DW/8)-1:0] req_strb
  , output logic [SYS_DW-1:0]     req_dat

  , input  logic               rsp_vld
  , output logic               rsp_gnt
  , input  logic [SYS_DW-1:0]  rsp_dat

  , output logic                               rpkt_vld
  , input  logic                               rpkt_gnt
  , output logic [VDW-SYS_AW-(SYS_DW/8)-1-1:0] rpkt_dat // {TGTID, INITID, LOAD = (S_DATA) }
);

localparam SYS_STRB  = SYS_DW / 8;

localparam LOC_VDW = AW + SYS_DW + <%=initid_width%> + 1 + SYS_DW/8;
localparam FB_VDW = VDW - SYS_AW - SYS_STRB - 1;

logic [LOC_VDW-1:0] req_pkt, tmp_req_attr;

logic [SYS_DW-1:0]     tmp_req_dat;
logic [(SYS_DW/8)-1:0] tmp_req_strb;

logic [AW-1:0]     tmp_req_adr;
logic              tmp_req_wr;

assign tmp_req_adr  = tpkt_dat [(SYS_DW + SYS_STRB + 1) +: AW];
assign tmp_req_dat  = tpkt_dat [SYS_DW-1:0];
assign tmp_req_strb = tpkt_dat [SYS_DW + SYS_STRB - 1 : SYS_DW];
assign tmp_req_wr   = tpkt_dat [SYS_DW + SYS_STRB];
assign req_pkt = {tpkt_dat[(VDW-1) -: <%=initid_width%>], tmp_req_adr, tmp_req_wr, tmp_req_strb, tmp_req_dat};

<%=cmm_prefix%>XFifo #(.DW(LOC_VDW), .DEPTH(OUTSTANDING_NUM))
  ReqBuff (.clk (clk), .rstn (rstn),
        .din    (req_pkt),     .we      (tpkt_vld),
        .dout   (tmp_req_attr), .re      (req_gnt),
        .full_n (tpkt_gnt),    .empty_n (req_vld)
);

assign {req_adr, req_wr, req_strb, req_dat} = tmp_req_attr [SYS_DW + SYS_STRB + 1 + AW - 1 : 0];

logic [<%=initid_width-1%>:0] init_id;

<%=cmm_prefix%>XFifo #(.DW(<%=initid_width%>), .DEPTH(OUTSTANDING_NUM))
  IdBuff (.clk (clk), .rstn (rstn),
        .din    (tmp_req_attr [(LOC_VDW-1) -: <%=initid_width%>]), .we (req_vld & req_gnt),
        .dout   (init_id),                       .re (rsp_vld & rpkt_gnt),
        .full_n (), .empty_n ()
);

logic [FB_VDW-1:0] tmp_rpkt_dat;

assign tmp_rpkt_dat = {ID [<%=targetid_width-1%>:0], init_id, rsp_dat};

<%=cmm_prefix%>XHndSk #(.D_WIDTH (FB_VDW))
	RspHndSk (.clk (clk), .rstn (rstn),
					  .vldi (rsp_vld),  .rdyi (rsp_gnt),
						.vldo (rpkt_vld), .rdyo (rpkt_gnt),
						.datai (tmp_rpkt_dat),
						.datao (rpkt_dat)
);

endmodule

module <%=cmm_prefix%>XFabric (
    input logic clk
  , input logic rstn
<%for i in range(n_initiators):%>
  , input  logic           <%=agents["I" + str(i)]%>_req_vld
  , input  logic           <%=agents["I" + str(i)]%>_req_wr
  , input  logic [<%=agents_addrwidth["I" + str(i)]-1%>:0] <%=agents["I" + str(i)]%>_req_adr
  , input  logic [<%=(agents_datawidth["I" + str(i)]//8)-1%>:0] <%=agents["I" + str(i)]%>_req_strb
  , input  logic [<%=agents_datawidth["I" + str(i)]-1%>:0] <%=agents["I" + str(i)]%>_req_dat
  , output logic           <%=agents["I" + str(i)]%>_req_gnt
  , output logic           <%=agents["I" + str(i)]%>_rsp_vld
  , output logic [<%=agents_datawidth["I" + str(i)]-1%>:0] <%=agents["I" + str(i)]%>_rsp_dat
  , input  logic           <%=agents["I" + str(i)]%>_rsp_gnt
<%%>

<%for j in range(n_targets):%>
  , output logic           <%=agents["T" + str(j)]%>_req_vld
  , output logic           <%=agents["T" + str(j)]%>_req_wr
  , output logic [<%=agents_addrwidth["T" + str(j)]-1%>:0] <%=agents["T" + str(j)]%>_req_adr
  , output logic [<%=(agents_datawidth["T" + str(j)]//8)-1%>:0] <%=agents["T" + str(j)]%>_req_strb
  , output logic [<%=agents_datawidth["T" + str(j)]-1%>:0] <%=agents["T" + str(j)]%>_req_dat
  , input  logic      <%=agents["T" + str(j)]%>_req_gnt
  , input  logic      <%=agents["T" + str(j)]%>_rsp_vld
  , input  logic [<%=agents_datawidth["T" + str(j)]-1%>:0] <%=agents["T" + str(j)]%>_rsp_dat
  , output logic           <%=agents["T" + str(j)]%>_rsp_gnt
<%%>
);

<%for i in range(n_initiators):%>
logic           <%=agents["I" + str(i)]%>_tpkt_vld;
logic [<%=vdw-1%>:0] <%=agents["I" + str(i)]%>_tpkt_pld;
logic           <%=agents["I" + str(i)]%>_tpkt_gnt;
logic           <%=agents["I" + str(i)]%>_rpkt_vld;
logic [<%=fb_vdw-1%>:0] <%=agents["I" + str(i)]%>_rpkt_pld;
logic           <%=agents["I" + str(i)]%>_rpkt_gnt;
<%%>

<%for j in range(n_targets):%>
logic           <%=agents["T" + str(j)]%>_tpkt_vld;
logic [<%=vdw-1%>:0] <%=agents["T" + str(j)]%>_tpkt_pld;
logic           <%=agents["T" + str(j)]%>_tpkt_gnt;
logic           <%=agents["T" + str(j)]%>_rpkt_vld;
logic [<%=fb_vdw-1%>:0] <%=agents["T" + str(j)]%>_rpkt_pld;
logic           <%=agents["T" + str(j)]%>_rpkt_gnt;
<%%>

<%=cmm_prefix%>XSwitch Switch ( .clk (clk), .rstn (rstn)
<%for i in range(n_initiators):%>
		  , .<%=agents["I" + str(i)]%>_req_vld (<%=agents["I" + str(i)]%>_tpkt_vld)
 		  , .<%=agents["I" + str(i)]%>_req_pkt (<%=agents["I" + str(i)]%>_tpkt_pld)
 		  , .<%=agents["I" + str(i)]%>_req_gnt (<%=agents["I" + str(i)]%>_tpkt_gnt)
 		  , .<%=agents["I" + str(i)]%>_rsp_vld (<%=agents["I" + str(i)]%>_rpkt_vld)
 		  , .<%=agents["I" + str(i)]%>_rsp_pkt (<%=agents["I" + str(i)]%>_rpkt_pld)
 		  , .<%=agents["I" + str(i)]%>_rsp_gnt (<%=agents["I" + str(i)]%>_rpkt_gnt)
<%%>

<%for j in range(n_targets):%>
		  , .<%=agents["T" + str(j)]%>_req_vld (<%=agents["T" + str(j)]%>_tpkt_vld)
 		  , .<%=agents["T" + str(j)]%>_req_pkt (<%=agents["T" + str(j)]%>_tpkt_pld)
 		  , .<%=agents["T" + str(j)]%>_req_gnt (<%=agents["T" + str(j)]%>_tpkt_gnt)
 		  , .<%=agents["T" + str(j)]%>_rsp_vld (<%=agents["T" + str(j)]%>_rpkt_vld)
 		  , .<%=agents["T" + str(j)]%>_rsp_pkt (<%=agents["T" + str(j)]%>_rpkt_pld)
 		  , .<%=agents["T" + str(j)]%>_rsp_gnt (<%=agents["T" + str(j)]%>_rpkt_gnt)
<%%>
);

<%for i in range(n_initiators):%>
<%	if agents_datawidth["I" + str(i)] < datawidth:%>
<%=cmm_prefix%>XMstRWSTrans #(.AW(<%=agents_addrwidth["I" + str(i)]%>), .DW(<%=agents_datawidth["I" + str(i)]%>), .VDW(<%=vdw%>), .OUTSTANDING_NUM(<%=outstanding_num["I" + str(i)]%>),
<%	else:%>
<%=cmm_prefix%>XMstRWTrans #(.AW(<%=agents_addrwidth["I" + str(i)]%>), .VDW(<%=vdw%>), .OUTSTANDING_NUM(<%=outstanding_num["I" + str(i)]%>),
<%	%>
													 .ID(<%=i%>), .SYS_AW (<%=addrwidth%>), .SYS_DW(<%=datawidth%>))
		<%=agents["I" + str(i)]%>_trans ( .clk (clk), .rstn (rstn)
					, .req_vld  (<%=agents["I" + str(i)]%>_req_vld)
					, .req_gnt  (<%=agents["I" + str(i)]%>_req_gnt)
					, .req_wr   (<%=agents["I" + str(i)]%>_req_wr)
					, .req_strb (<%=agents["I" + str(i)]%>_req_strb)
					, .req_adr  (<%=agents["I" + str(i)]%>_req_adr)
					, .req_dat  (<%=agents["I" + str(i)]%>_req_dat)

					, .tpkt_vld (<%=agents["I" + str(i)]%>_tpkt_vld)
					, .tpkt_dat (<%=agents["I" + str(i)]%>_tpkt_pld)
					, .tpkt_gnt (<%=agents["I" + str(i)]%>_tpkt_gnt)

					, .rpkt_vld (<%=agents["I" + str(i)]%>_rpkt_vld)
					, .rpkt_gnt (<%=agents["I" + str(i)]%>_rpkt_gnt)
					, .rpkt_dat (<%=agents["I" + str(i)]%>_rpkt_pld)

					, .rsp_vld (<%=agents["I" + str(i)]%>_rsp_vld)
					, .rsp_gnt (<%=agents["I" + str(i)]%>_rsp_gnt)
					, .rsp_dat (<%=agents["I" + str(i)]%>_rsp_dat)
				);
<%%>

<%for j in range(n_targets):%>
<%	if agents_datawidth["T" + str(j)] < datawidth:%>
<%=cmm_prefix%>XSlvRWSTrans #(.AW(<%=agents_addrwidth["T" + str(j)]%>), .DW(<%=agents_datawidth["T" + str(j)]%>), .VDW(<%=vdw%>), .OUTSTANDING_NUM(<%=outstanding_num["T" + str(j)]%>),
<%	else:%>
<%=cmm_prefix%>XSlvRWTrans #(.AW(<%=agents_addrwidth["T" + str(j)]%>), .VDW(<%=vdw%>), .OUTSTANDING_NUM(<%=outstanding_num["T" + str(j)]%>),
<%	%>
													 .ID(<%=j%>), .SYS_AW (<%=addrwidth%>), .SYS_DW(<%=datawidth%>))
		<%=agents["T" + str(j)]%>_trans ( .clk (clk), .rstn (rstn)
					, .tpkt_vld (<%=agents["T" + str(j)]%>_tpkt_vld)
					, .tpkt_dat (<%=agents["T" + str(j)]%>_tpkt_pld)
					, .tpkt_gnt (<%=agents["T" + str(j)]%>_tpkt_gnt)

					, .req_vld  (<%=agents["T" + str(j)]%>_req_vld)
					, .req_gnt  (<%=agents["T" + str(j)]%>_req_gnt)
					, .req_adr  (<%=agents["T" + str(j)]%>_req_adr)
					, .req_wr   (<%=agents["T" + str(j)]%>_req_wr)
					, .req_strb (<%=agents["T" + str(j)]%>_req_strb)
					, .req_dat  (<%=agents["T" + str(j)]%>_req_dat)

					, .rsp_vld (<%=agents["T" + str(j)]%>_rsp_vld)
					, .rsp_gnt (<%=agents["T" + str(j)]%>_rsp_gnt)
					, .rsp_dat (<%=agents["T" + str(j)]%>_rsp_dat)

					, .rpkt_vld (<%=agents["T" + str(j)]%>_rpkt_vld)
					, .rpkt_gnt (<%=agents["T" + str(j)]%>_rpkt_gnt)
					, .rpkt_dat (<%=agents["T" + str(j)]%>_rpkt_pld)
				);
<%%>

endmodule

// EOF
