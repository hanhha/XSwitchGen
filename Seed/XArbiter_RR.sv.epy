// HMTH (c)
// Round-robin arbiter

module <%=prefix%>XArbiter_RR #(parameter REQ_N = <%=n_initiators%>) (
    input logic clk
  , input logic rstn

  , input  logic [REQ_N-1:0] req
  , output logic [REQ_N-1:0] gnt
);

logic [REQ_N-1:0] mask, nxt_mask;
logic [REQ_N-1:0] masked_req;

always @(*) begin
<%for i in range(0,n_initiators):%>
<%  if i == 0:%>
  if      (gnt[<%=i%>]) nxt_mask = {{(REQ_N-<%=i+1%>){1'b1}}, <%=i+1%>'b0};
<%  else:%>
  else if (gnt[<%=i%>]) nxt_mask = {{(REQ_N-<%=i+1%>){1'b1}}, <%=i+1%>'b0};
<%  %>
<%%>
  else nxt_mask = mask;
end

`ifndef SELECT_SRSTn
always @(posedge clk or negedge rstn) begin
`else
always @(posedge clk) begin
`endif
  if (~rstn) mask <= {REQ_N{1'b1}};
  else       mask <= nxt_mask;
end

assign masked_req = req & mask;

logic [REQ_N-1:0] pre_gnt, pos_gnt;

// Before pivot
always @(*) begin
  case (1'b1)
<%for i in range(0,n_initiators):%>
    req [<%=i%>] : pre_gnt = <%=n_initiators%>'b1 << <%=i%>;
<%%>
    default : pre_gnt = <%=n_initiators%>'b0;
  endcase
end

// After pivot
always @(*) begin
  case (1'b1)
<%for i in range(0,n_initiators):%>
    masked_req [<%=i%>] : pos_gnt = <%=n_initiators%>'b1 << <%=i%>;
<%%>
    default        : pos_gnt = <%=n_initiators%>'b0;
  endcase
end

assign gnt = |masked_req ? pos_gnt : pre_gnt;

`ifndef SYNTHESIS
  `ifndef RICHMAN
    integer ones;
    integer i;

    always @(*) begin
      ones = 0;
      for (i = 0; i < REQ_N; i++) begin 
        ones = ones + gnt [i];
      end
      if (req) assert (ones == 1);
    end
  `else
    always @(*) begin
      assert (req |-> $onehot0 (gnt));
    end
  `endif
`endif

endmodule
// EOF
